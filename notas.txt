Notas de desenvolvimento

1) Criação do repositório (primeiro com o arquivo de Lista)
2) Renomear arquivos:
    Atividade_Lista__pilha_e_fila (1).pdf -> Atividade_Lista__pilha_e_fila.pdf
    main.c -> MainListaLigadaD.c
3) Organizar os arquivos em uma estrutura de diretórios clara e consistente,
conforme atividade anterior.
4) Alterado no MainListaLigadaD: main: #include "ListaLigadaD.h" -> #include "ListaLigadaD.c"
5) Alterado no ListaLigadaD: #include "ListaLigadaD.h" -> #include "../include/ListaLigadaD.h"

6) Importar arquivos de pilha estatica
7) Renomear arquivos:
    main.c -> MainPilhaEstatica.c
    pilhaEstatica.c -> PilhaEstatica.c
    pilhaEstatica.h -> PilhaEstatica.h
8) Alterado no MainPilhaEstatica: main: #include "pilhaEstatica.h" -> #include "PilhaEstatica.c"
9) Alterado no PilhaEstatica: #include "pilhaEstatica.h" -> #include "../include/PilhaEstatica.h"

10) Importar arquivos de fila dinamica
11) Separado o arquivo fila_dinamica.c em arquivos:
    de interface (FilaDinamica.h) e de implementação (FilaDinamica.c)
12) Renomeado o arquivo:
    usaFilaDinamica.c -> MainFilaDinamica.c
13) Alterado no MainFilaDinamica: main: #include "filaDinamica.h" -> #include "FilaDinamica.c"
14) Alterado no PilhaEstatica: #include "FilaDinamica.h" -> #include "../include/FilaDinamica.h"

15) Importar arquivos de deque
16) Separado o arqvuivo dequeDinamico.c em arquivos:
    de interface (DequeDinamico.h) e de implementação (DequeDinamico.c)
17) Renomeado o arquivo:
    usaDeque.c -> MainDeque.c
18) Alterado no MainDeque: main: #include "dequeDinamico.h" -> #include "DequeDinamico.c"
19) Alterado no DequeDinamico: #include "DequeDinamico.h" -> #include "../include/DequeDinamico.h"

20) Iniciar a atividade da lista: revisar os conceitos e o código da lista ligada dinâmica
21) Copiados os arquivos originais da aula de lista ligada dinamica e renomeados:
ListaDuplaLigada.c, ListaDuplaLigada.h, MainListaDuplaLigada.c
22) Alterado no ListaDuplaLigada: #include "ListaDuplaLigada.h" -> #include "../include/ListaDuplaLigada.h"

23) Modificação na struct ELEMENTO => campo adicional *ant:
        typedef struct aux {
        REGISTRO reg;
        struct aux *ant, *prox;
        } ELEMENTO;

24) Função de inserção: considerar os casos de inserção no início, no meio e no final (com lista vazia ou não)
25) Função de deleção: considerar os casos de deleção de um único elemento, do primeiro, do último e de um elemento do meio
26) Primeiro teste realizado:
    inserção no início OK; no meio OK; no final OK
    deleção elemento único OK; primeiro OK, meio OK, final OK, inexistente OK (mensagem de erro)

27) Inicar a atividade de pilha: criar a função solicitada no arquivo de interface:
        void exibirPilhaInvertida(PILHA* p);
    e de implementação:
        void exibirPilhaInvertida(PILHA* p) {
            printf("Pilha (da base para o topo): \" ");
            for (int i = 0; i <= p->topo; i++){
                printf("%i ", p->A[i].chave);
            }
            printf("\"\n");
        }
28) Ajustes em MainPilhaEstatica:
    função help(): adicionada opção para pilha invertida:
        printf("   x : imprimir pilha invertida\n");

    criação da função exibirInvertida():
        void exibirInvertida(PILHA* p) {
            exibirPilhaInvertida(p);
        }

    função main(): adicionada ação para pilha invertida:
        case 'x':
            exibirInvertida(&pilha);
            break;
29) Teste realizado:
    exibir pilha e pilha invertida vazias: OK 
    exibir pilha e pilha invertida com um elemento: OK
    exibir pilha e pilha invertida com cinco elementos: OK

30) Iniciar atividade de deque: criar a função solicitada no arquivo de interface:
        bool encontrarMax(DEQUE* d, int* max);
    e de implementação:
        bool encontrarMax(DEQUE* d, int* max) {
            bool resposta = false;
            PONT end = d->cabeca->prox;
            // verifica se há elementos no deque
            if (end != d->cabeca) {
                *max = end->reg.chave;
                resposta = true;
                // percorre o deque procurando o maior elemento
                while (end != d->cabeca) {
                    if (end->reg.chave > *max) *max = end->reg.chave;
                    end = end->prox;
                }
            }
            return resposta;
        }
31) Ajuste em MainDeque:
    função help(): adicionada opção para valor máximo:
        printf("   m : imprimir a maior chave do deque\n");

    criação da função valorMax:
        void valorMax(DEQUE* d) {
            int max; // Variável para armazenar o valor máximo
            if (encontrarMax(d, &max)) // Passa o endereço de max
                printf("A maior chave do deque é %i\n", max);
            else
                printf("O deque está vazio!\n");
        }

    função main(): adicionada ação valor máximo do deque:
        case 'm' : valorMax(&deque); break;
32) Teste realizado:
    Com o deque vazio: OK
    Com um elemento: OK
    Com dois elementos em ordem crescente: OK
    Com dois elementos em ordem decrescente: OK
    Com cinco elementos: OK

33) Iniciar a atividade de fila
34) Alteração da estrutura na interface:
        typedef struct {
        PONT cabeca;
        PONT fim;
        } FILA;

35) Alteração das funções para considerar o nó cabeça:
        void inicializarFila(FILA* f) {
            f->cabeca = (PONT)malloc(sizeof(ELEMENTO));
            f->cabeca->prox = NULL;
            f->fim = NULL;
        }

        int tamanho(FILA* f) {
        PONT end = f->cabeca->prox;
        int tam = 0;
        while (end != NULL) {
            tam++;
            end = end->prox;
        }
        return tam;
        }

        int tamanhoEmBytes(FILA* f) {
        return ((tamanho(f) + 1) * sizeof(ELEMENTO)) + sizeof(FILA);
        }

    criação de uma função de reinicialização (que preserva o nó cabeça)
        void reinicializarFila(FILA* f) {
            PONT end = f->cabeca->prox;
            while (end != NULL) {
                PONT apagar = end;
                end = end->prox;
                free(apagar);
            }
            f->cabeca->prox = NULL;
            f->fim = NULL;
        }    

    ajuste da função de destruição (desaloca o nó cabeça também)   
        void destruirFila(FILA* f) {
            PONT end = f->cabeca->prox;
            // Libera todos os elementos válidos
            while (end != NULL) {
                PONT apagar = end;
                end = end->prox;
                free(apagar);
            }
            // Libera o nó cabeça
            free(f->cabeca);
            f->cabeca = NULL;
            f->fim = NULL;
        }

    ajuste da funçao retornarPrimeiro
        PONT retornarPrimeiro(FILA* f, TIPOCHAVE* ch) {
            // Verifica se há elementos na fila
            if (f->cabeca->prox == NULL) {
                return NULL; // se estiver vazia, retorna NULL
            }
            // Atribui a chave do primeiro elemento e retorna o ponteiro
            *ch = f->cabeca->prox->reg.chave;
            return f->cabeca->prox;
        }

    ajuste da função retornarUltimo
        PONT retornarUltimo(FILA* f, TIPOCHAVE* ch) {
            // Verifica se há elementos na fila
            if (f->cabeca->prox == NULL) {
                return NULL; // se estiver vazia, retorna NULL
            }
            // Atribui a chave do ultimo elemento e retorna o ponteiro
            *ch = f->fim->reg.chave;
            return f->fim;
        }

    ajuste da função inserirNaFila
        bool inserirNaFila(FILA* f, REGISTRO reg) {
        PONT novo = (PONT)malloc(sizeof(ELEMENTO)); //aloca memória para o novo elemento
        novo->reg = reg; //copia o registro para o novo elemento
        novo->prox = NULL; //ajusta o ponteiro de próx para NULL (pois é o último elemento)
        if (f->cabeca->prox == NULL) { //inserção na fila vazia
            f->cabeca->prox = novo;
        } else { //inserção na fila preenchida
            f->fim->prox = novo;
        }
        f->fim = novo; //atualização do ponteiro fim
        return true;
        }    

    ajuste da função excluirDaFila
        bool excluirDaFila(FILA* f, REGISTRO* reg) {
        if (f->cabeca->prox == NULL) {
            return false; //não é possível excluir de fila vazia
        }
        *reg = f->cabeca->prox->reg; //copia o registro do primeiro elemento
        PONT apagar = f->cabeca->prox; //copia o ponteiro para o primeiro elemento
        f->cabeca->prox = f->cabeca->prox->prox; //ajusta o ponteiro inicial para o segundo elemento
        free(apagar); //desaloca o primeiro elemento
        if (f->cabeca->prox == NULL) { //quando a fila fica vazia
            f->fim = NULL; //ajusta o ponteiro de fim para NULL
        }
        return true;
        }

    ajuste da função exibirFila
        void exibirFila(FILA* f) {
        PONT end = f->cabeca->prox;
        printf("Fila: \" ");
        while (end != NULL) {
            printf("%d ", end->reg.chave);
            end = end->prox;
        }
        printf("\"\n");
        }

    ajuste na funçao buscaSeq
        PONT buscaSeq(FILA* f, TIPOCHAVE ch) {
        PONT pos = f->cabeca->prox;
        while (pos != NULL) {
            if (pos->reg.chave == ch) return pos;
            pos = pos->prox;
        }
        return NULL;
        }

    Com o uso de um nó cabeça, a necessidade de um nó sentinela (dinâmico ou local) é
    completamente eliminada. A busca pode ser realizada diretamente em todos os elementos
    válidos da fila, partindo de cabeca->prox, até o final (NULL).

    remover a função buscaSeqSent1 e buscaSeqSent2 (na implementação e na interface)

alteracao no main
help()
printf("   r : reinicializar (zerar) fila\n");
printf("   d : destruir (desalocar) fila\n");

void reinicializar(FILA* f){
     reiniciarFila(f);
     printf("Fila zerada.\n");
}

void destruir(FILA* f){
     destruirFila(f);
     printf("Fila desalocada.\n");
}

remocao da buscaSeqSent1 e buscaSeqSent2
void buscar(FILA* f){
  TIPOCHAVE ch;
  scanf("%i",&ch);
  PONT posicao = buscaSeq(f,ch);
  if (posicao != NULL) printf("Elemento %i encontrado no endereco %p (busca sequencial).\n",ch,posicao);
  else printf("Nao foi possivel encontrar elemento %i.\n",ch);
}

main()
    case 'r' : reinicializar(&fila); break;



XX) Teste realizado:
    Com a fila vazia: OK
    Com um elemento: OK
    Com dois elementos: OK
    Com cinco elementos: OK
    Inserção: OK
    Remoção: OK