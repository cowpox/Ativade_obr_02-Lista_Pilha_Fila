Notas de desenvolvimento

1) Criação do repositório (primeiro com o arquivo de Lista)
2) Renomear arquivos:
    Atividade_Lista__pilha_e_fila (1).pdf -> Atividade_Lista__pilha_e_fila.pdf
    main.c -> MainListaLigadaD.c
3) Organizar os arquivos em uma estrutura de diretórios clara e consistente,
conforme atividade anterior.
4) Alterado no MainListaLigadaD: main: #include "ListaLigadaD.h" -> #include "ListaLigadaD.c"
5) Alterado no ListaLigadaD: #include "ListaLigadaD.h" -> #include "../include/ListaLigadaD.h"

6) Importar arquivos de pilha estatica
7) Renomear arquivos:
    main.c -> MainPilhaEstatica.c
    pilhaEstatica.c -> PilhaEstatica.c
    pilhaEstatica.h -> PilhaEstatica.h
8) Alterado no MainPilhaEstatica: main: #include "pilhaEstatica.h" -> #include "PilhaEstatica.c"
9) Alterado no PilhaEstatica: #include "pilhaEstatica.h" -> #include "../include/PilhaEstatica.h"

10) Importar arquivos de fila dinamica
11) Separado o arquivo fila_dinamica.c em arquivos:
    de interface (FilaDinamica.h) e de implementação (FilaDinamica.c)
12) Renomeado o arquivo:
    usaFilaDinamica.c -> MainFilaDinamica.c
13) Alterado no MainFilaDinamica: main: #include "filaDinamica.h" -> #include "FilaDinamica.c"
14) Alterado no PilhaEstatica: #include "FilaDinamica.h" -> #include "../include/FilaDinamica.h"

15) Importar arquivos de deque
16) Separado o arqvuivo dequeDinamico.c em arquivos:
    de interface (DequeDinamico.h) e de implementação (DequeDinamico.c)
17) Renomeado o arquivo:
    usaDeque.c -> MainDeque.c
18) Alterado no MainDeque: main: #include "dequeDinamico.h" -> #include "DequeDinamico.c"
19) Alterado no DequeDinamico: #include "DequeDinamico.h" -> #include "../include/DequeDinamico.h"

20) Iniciar a atividade da lista: revisar os conceitos e o código da lista ligada dinâmica
21) Copiados os arquivos originais da aula de lista ligada dinamica e renomeados:
ListaDuplaLigada.c, ListaDuplaLigada.h, MainListaDuplaLigada.c
22) Alterado no ListaDuplaLigada: #include "ListaDuplaLigada.h" -> #include "../include/ListaDuplaLigada.h"

23) Modificação na struct ELEMENTO => campo adicional *ant:
        typedef struct aux {
        REGISTRO reg;
        struct aux *ant, *prox;
        } ELEMENTO;

24) Função de inserção: considerar os casos de inserção no início, no meio e no final (com lista vazia ou não)
25) Função de deleção: considerar os casos de deleção de um único elemento, do primeiro, do último e de um elemento do meio
26) Primeiro teste realizado:
    inserção no início OK; no meio OK; no final OK
    deleção elemento único OK; primeiro OK, meio OK, final OK, inexistente OK (mensagem de erro)

27) Inicar a atividade de pilha: criar a função solicitada no arquivo de interface:
        void exibirPilhaInvertida(PILHA* p);
    e de implementação:
        void exibirPilhaInvertida(PILHA* p) {
            printf("Pilha (da base para o topo): \" ");
            for (int i = 0; i <= p->topo; i++){
                printf("%i ", p->A[i].chave);
            }
            printf("\"\n");
        }
28) Ajustes em MainPilhaEstatica:
    função help(): adicionada opção para pilha invertida:
        printf("   x : imprimir pilha invertida\n");

    criação da função exibirInvertida():
        void exibirInvertida(PILHA* p) {
            exibirPilhaInvertida(p);
        }

    função main(): adicionada ação para pilha invertida:
        case 'x':
            exibirInvertida(&pilha);
            break;
29) Teste realizado:
    exibir pilha e pilha invertida vazias: OK 
    exibir pilha e pilha invertida com um elemento: OK
    exibir pilha e pilha invertida com cinco elementos: OK

30) Iniciar atividade de deque: criar a função solicitada no arquivo de interface:
        bool encontrarMax(DEQUE* d, int* max);
    e de implementação:
        bool encontrarMax(DEQUE* d, int* max) {
            bool resposta = false;
            PONT end = d->cabeca->prox;
            // verifica se há elementos no deque
            if (end != d->cabeca) {
                *max = end->reg.chave;
                resposta = true;
                // percorre o deque procurando o maior elemento
                while (end != d->cabeca) {
                    if (end->reg.chave > *max) *max = end->reg.chave;
                    end = end->prox;
                }
            }
            return resposta;
        }
31) Ajuste em MainDeque:
    função help(): adicionada opção para valor máximo:
        printf("   m : imprimir a maior chave do deque\n");

    criação da função valorMax:
        void valorMax(DEQUE* d) {
            int max; // Variável para armazenar o valor máximo
            if (encontrarMax(d, &max)) // Passa o endereço de max
                printf("A maior chave do deque é %i\n", max);
            else
                printf("O deque está vazio!\n");
        }

    função main(): adicionada ação valor máximo do deque:
        case 'm' : valorMax(&deque); break;
32) Teste realizado:
    Com o deque vazio: OK
    Com um elemento: OK
    Com dois elementos em ordem crescente: OK
    Com dois elementos em ordem decrescente: OK
    Com cinco elementos: OK

33) 
